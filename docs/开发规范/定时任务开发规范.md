# 定时任务开发规范

## 概述

定时任务分为两部分:
1. **Command (命令)** - 可手动执行或定时调度的控制台命令
2. **Job (队列任务)** - 异步执行的后台任务

**开发原则**: Command 负责参数处理和任务调度，Job 负责具体的业务逻辑执行。

---

## 1. Command 开发规范

### 1.1 文件位置

`Modules/{ModuleName}/app/Console/Commands/{Action}Command.php`

**示例**: `Modules/Invoice/app/Console/Commands/SyncInputInvoicesCommand.php`

### 1.2 标准模板

```php
<?php

namespace Modules\{Module}\Console\Commands;

use Illuminate\Console\Command;
use Modules\{Module}\Jobs\{Action}Job;

/**
 * {功能描述}命令
 */
class {Action}Command extends Command
{
    /**
     * 命令签名
     */
    protected $signature = '{module}:{action}
                            {--option1= : 选项1说明}
                            {--option2= : 选项2说明}
                            {--queue : 使用队列异步执行}';

    /**
     * 命令描述
     */
    protected $description = '{命令功能的详细描述}';

    /**
     * Execute the console command.
     */
    public function handle(): int
    {
        // 1. 获取命令参数
        $option1 = $this->option('option1');
        $useQueue = $this->option('queue');

        // 2. 参数验证和处理
        if (!$this->validateParams($option1)) {
            $this->error('参数验证失败');
            return self::FAILURE;
        }

        // 3. 显示任务信息
        $this->info("开始执行任务");
        $this->newLine();

        // 4. 执行任务
        if ($useQueue) {
            // 使用队列异步执行
            {Action}Job::dispatch($param1, $param2);
            $this->info("✓ 任务已添加到队列");
        } else {
            // 同步执行
            try {
                $service = app(\Modules\{Module}\Services\{Service}::class);
                $result = $service->performAction($param1, $param2);

                $this->info("✓ 任务执行成功");

                // 显示结果表格
                $this->table(['列1', '列2'], $tableData);

            } catch (\Exception $e) {
                $this->error("✗ 任务执行失败: {$e->getMessage()}");
                return self::FAILURE;
            }
        }

        return self::SUCCESS;
    }

    /**
     * 私有辅助方法
     */
    protected function validateParams($param): bool
    {
        // 验证逻辑
        return true;
    }
}
```

### 1.3 命令签名规范

**格式**: `{module}:{action}`

| 命令 | 说明 |
|------|------|
| `invoice:sync-input` | 同步进项发票 |
| `invoice:download-input-files` | 下载进项发票文件 |
| `invoice:retry-failed` | 重试失败的开票任务 |

**选项参数规范**:
```php
{--nsrsbh= : 指定纳税人识别号}
{--company-id= : 指定公司ID}
{--start-date= : 开始日期 (格式: YYYY-MM-DD)}
{--days=7 : 最近N天的数据}  // 带默认值
{--queue : 使用队列异步执行}  // 布尔标志
```

### 1.4 输出规范

```php
// ✅ 使用正确的输出方法
$this->info('正常信息');           // 绿色
$this->error('错误信息');          // 红色
$this->warn('警告信息');           // 黄色
$this->comment('注释信息');        // 灰色
$this->newLine();                  // 空行

// ✅ 使用表格展示数据
$this->table(
    ['列1', '列2', '列3'],
    $tableData
);

// ✅ 使用进度条
$bar = $this->output->createProgressBar(count($items));
$bar->start();
foreach ($items as $item) {
    // 处理逻辑
    $bar->advance();
}
$bar->finish();
```

### 1.5 常用模式

#### 批量处理模式
```php
public function handle(): int
{
    // 获取要处理的对象列表
    $items = $this->getItemsToProcess();

    if ($items->isEmpty()) {
        $this->error('没有找到需要处理的项目');
        return self::FAILURE;
    }

    $this->info("找到 {$items->count()} 个项目");
    $results = [];

    foreach ($items as $item) {
        $this->info("正在处理: {$item->name}");

        if ($this->option('queue')) {
            ProcessJob::dispatch($item);
            $this->info("  ✓ 任务已添加到队列");
        } else {
            try {
                $result = $this->processItem($item);
                $results[] = $this->formatResult($item, $result);
                $this->info("  ✓ 处理成功");
            } catch (\Exception $e) {
                $this->error("  ✗ 处理失败: {$e->getMessage()}");
                $results[] = $this->formatError($item, $e);
            }
        }

        $this->newLine();
    }

    // 显示汇总
    if (!empty($results)) {
        $this->table(['项目', '状态', '详情'], $results);
    }

    return self::SUCCESS;
}
```

---

## 2. Job (队列任务) 开发规范

### 2.1 文件位置

`Modules/{ModuleName}/app/Jobs/{Action}Job.php`

**示例**: `Modules/Invoice/app/Jobs/SyncInputInvoicesJob.php`

### 2.2 标准模板

```php
<?php

namespace Modules\{Module}\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Psr\Log\LoggerInterface;

/**
 * {任务描述}队列任务
 */
class {Action}Job implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * 任务最大尝试次数
     *
     * @var int
     */
    public $tries = 3;

    /**
     * 任务超时时间（秒）
     *
     * @var int
     */
    public $timeout = 300;

    /**
     * 任务参数（使用 protected 存储）
     */
    protected string $param1;
    protected array $param2;

    /**
     * Create a new job instance.
     *
     * @param string $param1 参数1说明
     * @param array $param2 参数2说明
     */
    public function __construct(string $param1, array $param2)
    {
        $this->param1 = $param1;
        $this->param2 = $param2;
    }

    /**
     * Execute the job.
     */
    public function handle(
        {Service} $service,
        LoggerInterface $logger
    ): void {
        $logger->info('开始执行任务', [
            'param1' => $this->param1,
            'param2' => $this->param2
        ]);

        try {
            // 执行业务逻辑
            $result = $service->performAction(
                $this->param1,
                $this->param2
            );

            $logger->info('任务执行完成', [
                'result' => $result
            ]);

        } catch (\Exception $e) {
            $logger->error('任务执行失败', [
                'param1' => $this->param1,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            // 重新抛出异常以触发重试机制
            throw $e;
        }
    }

    /**
     * 任务失败处理
     */
    public function failed(\Throwable $exception): void
    {
        app(LoggerInterface::class)->error('任务最终失败', [
            'param1' => $this->param1,
            'error' => $exception->getMessage()
        ]);

        // 可选: 发送失败通知、更新状态等
    }
}
```

### 2.3 必须遵守

| 规则 | 说明 |
|------|------|
| 实现 `ShouldQueue` | 标记为队列任务 |
| 使用 4 个 traits | `Dispatchable, InteractsWithQueue, Queueable, SerializesModels` |
| 定义 `$tries` | 最大重试次数 (推荐 3) |
| 定义 `$timeout` | 超时时间(秒)，根据任务复杂度设置 |
| 参数使用 `protected` | 构造函数参数存储为 protected 属性 |
| 实现 `handle()` | 业务逻辑执行方法，可依赖注入 |
| 实现 `failed()` | 失败后的处理逻辑 |
| 记录日志 | 开始、完成、失败都要记录日志 |
| 重新抛出异常 | `throw $e;` 触发重试机制 |

### 2.4 超时时间建议

| 任务类型 | 超时时间 |
|---------|---------|
| 简单 API 调用 | 60 - 120 秒 |
| 数据同步 | 300 - 600 秒 (5-10 分钟) |
| 文件下载/处理 | 600 - 1800 秒 (10-30 分钟) |
| 大批量处理 | 1800+ 秒 (30 分钟以上) |

---

## 3. 调度配置规范

### 3.1 配置位置

`routes/console.php`

### 3.2 标准配置

```php
<?php

use Illuminate\Support\Facades\Schedule;

// 每小时执行一次
Schedule::command('invoice:sync-input --queue')
    ->hourly()
    ->withoutOverlapping()
    ->runInBackground();

// 每天凌晨执行
Schedule::command('invoice:cleanup-old-records')
    ->daily()
    ->at('01:00')
    ->withoutOverlapping();

// 每周执行
Schedule::command('report:weekly')
    ->weekly()
    ->mondays()
    ->at('09:00');

// 自定义 Cron 表达式
Schedule::command('custom:task')
    ->cron('*/15 * * * *')  // 每 15 分钟
    ->withoutOverlapping();
```

### 3.3 常用调度方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `hourly()` | 每小时执行 | 每小时的第 0 分钟 |
| `daily()` | 每天执行 | 每天凌晨 00:00 |
| `dailyAt('13:00')` | 每天指定时间 | 每天 13:00 |
| `weekly()` | 每周执行 | 每周日 00:00 |
| `monthly()` | 每月执行 | 每月 1 日 00:00 |
| `cron('* * * * *')` | 自定义 Cron | 灵活控制 |

### 3.4 常用约束方法

| 方法 | 说明 |
|------|------|
| `withoutOverlapping()` | 防止任务重叠执行（推荐使用） |
| `runInBackground()` | 在后台运行，不阻塞其他任务 |
| `onOneServer()` | 多服务器环境下只在一台服务器执行 |
| `runInBackground()` | 后台运行 |
| `evenInMaintenanceMode()` | 维护模式下也执行 |

### 3.5 环境控制

```php
// 仅生产环境执行
Schedule::command('invoice:sync-input')
    ->hourly()
    ->environments(['production']);

// 排除特定环境
Schedule::command('test:command')
    ->hourly()
    ->environments(['local', 'staging']);
```

---

## 4. 最佳实践

### 4.1 Command 和 Job 的职责划分

**Command 职责**:
- ✅ 解析和验证命令参数
- ✅ 显示任务进度和结果
- ✅ 提供同步/异步执行选项
- ✅ 批量调度多个 Job
- ❌ 不包含复杂业务逻辑

**Job 职责**:
- ✅ 执行具体的业务逻辑
- ✅ 调用 Service 层
- ✅ 记录详细日志
- ✅ 处理异常和重试
- ❌ 不负责参数验证和格式化输出

### 4.2 示例对比

```php
// ❌ 不好: Command 包含业务逻辑
class SyncCommand extends Command {
    public function handle() {
        // 直接在 Command 中写业务代码
        $data = Http::get('api/endpoint')->json();
        Model::create($data);
    }
}

// ✅ 好: Command 调用 Job 或 Service
class SyncCommand extends Command {
    public function handle() {
        if ($this->option('queue')) {
            SyncJob::dispatch($params);
        } else {
            $service = app(SyncService::class);
            $service->sync($params);
        }
    }
}
```

### 4.3 日志记录规范

```php
// ✅ 记录关键信息
$logger->info('任务开始', [
    'task_type' => 'sync_invoices',
    'params' => $this->params,
    'triggered_at' => now()
]);

// ✅ 记录成功结果
$logger->info('任务完成', [
    'task_id' => $task->id,
    'total' => 100,
    'success' => 95,
    'failed' => 5,
    'duration' => $duration
]);

// ✅ 记录错误详情
$logger->error('任务失败', [
    'params' => $this->params,
    'error' => $e->getMessage(),
    'trace' => $e->getTraceAsString()
]);
```

### 4.4 队列配置建议

```php
// 为不同类型任务使用不同队列
SyncJob::dispatch($params)->onQueue('sync');
DownloadJob::dispatch($params)->onQueue('download');
NotificationJob::dispatch($params)->onQueue('notifications');

// 延迟执行
SyncJob::dispatch($params)->delay(now()->addMinutes(5));

// 设置连接
SyncJob::dispatch($params)->onConnection('redis');
```

---

## 5. 测试

### 5.1 测试 Command

```php
public function test_sync_command_success()
{
    $this->artisan('invoice:sync-input --nsrsbh=123456')
        ->expectsOutput('任务执行成功')
        ->assertExitCode(Command::SUCCESS);
}
```

### 5.2 测试 Job

```php
public function test_sync_job_dispatches()
{
    Queue::fake();

    SyncJob::dispatch('nsrsbh', ['rqq' => '2024-01-01']);

    Queue::assertPushed(SyncJob::class, function ($job) {
        return $job->nsrsbh === 'nsrsbh';
    });
}
```

---

## 6. 常见问题

### 6.1 任务执行时间过长

**解决方案**:
- 增加 `$timeout` 值
- 将大任务拆分为多个小任务
- 使用批量处理，每次处理部分数据

### 6.2 任务重复执行

**解决方案**:
- 使用 `withoutOverlapping()`
- 在任务开始前检查是否有正在执行的任务
- 使用 Redis 锁机制

### 6.3 队列堆积

**解决方案**:
- 增加 worker 进程数量
- 优化任务执行效率
- 使用优先级队列
- 为不同类型任务使用不同队列

---

## 7. 检查清单

**Command 开发**:
- [ ] 命令签名符合 `{module}:{action}` 格式
- [ ] 提供 `--queue` 选项支持异步执行
- [ ] 实现了参数验证
- [ ] 使用正确的输出方法（`info`, `error`, `table`）
- [ ] 返回正确的退出码（`SUCCESS` / `FAILURE`）

**Job 开发**:
- [ ] 实现了 `ShouldQueue` 接口
- [ ] 使用了 4 个必需的 traits
- [ ] 定义了 `$tries` 和 `$timeout`
- [ ] 实现了 `handle()` 方法
- [ ] 实现了 `failed()` 方法
- [ ] 记录了详细日志
- [ ] 正确处理异常并重新抛出

**调度配置**:
- [ ] 在 `routes/console.php` 中配置
- [ ] 使用了 `withoutOverlapping()`
- [ ] 考虑了 `runInBackground()`
- [ ] 设置了合适的执行频率

---

## 8. 相关文档

- [Service开发规范.md](./Service开发规范.md) - Service 层负责具体业务逻辑
- [命名规范.md](./命名规范.md) - 文件和类命名规范
